<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Ambilight</title>
    <style>
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="AmbilightConfigPage" data-role="page" class="page type-interior pluginConfigurationPage" data-require="emby-input,emby-button,emby-select,emby-checkbox">
        <div data-role="content">
            <div class="content-primary">

                <!-- Tab Navigation -->
                <div class="verticalSection">
                    <div class="sectionTitleContainer flex align-items-center">
                        <h2 class="sectionTitle">Ambilight Plugin</h2>
                    </div>
                    <div class="selectContainer" style="margin-bottom: 2em;">
                        <select id="tabSelector" is="emby-select" class="emby-select-withcolor emby-select">
                            <option value="settings">Settings</option>
                            <option value="manager">Extraction Manager</option>
                        </select>
                    </div>
                </div>

                <!-- Settings Tab -->
                <div id="settingsTab">
                <form id="AmbilightConfigForm">
                    <h2 class="sectionTitle">Extraction</h2>

                    <div class="checkboxContainer checkboxContainer-withDescription">
                        <label class="emby-checkbox-label">
                            <input id="ExtractNewlyAddedItems" type="checkbox" is="emby-checkbox" />
                            <span>Extract newly added items</span>
                        </label>
                        <div class="fieldDescription">When enabled, ambilight data is automatically extracted when new videos are added to non-excluded libraries.</div>
                    </div>

                    <div class="selectContainer">
                        <label class="selectLabel" for="ExtractionPriority">Extraction priority</label>
                        <select is="emby-select" id="ExtractionPriority" class="emby-select-withcolor emby-select">
                            <option value="newest_first">Newest first</option>
                            <option value="oldest_first">Oldest first</option>
                            <option value="alphabetical">Alphabetical</option>
                            <option value="movies_newest_first">Movies newest first</option>
                        </select>
                        <div class="fieldDescription">Order in which pending videos are extracted.</div>
                    </div>

                    <div class="selectContainer">
                        <label class="selectLabel" for="ExcludedLibraries">Excluded libraries</label>
                        <select id="ExcludedLibraries" is="emby-select" class="emby-select-withcolor emby-select" multiple>
                        </select>
                        <div class="fieldDescription">Libraries to skip when extracting ambilight data.</div>
                    </div>

                    <div class="selectContainer">
                        <label class="selectLabel" for="HardwareAcceleration">Hardware acceleration</label>
                        <select is="emby-select" id="HardwareAcceleration" class="emby-select-withcolor emby-select">
                            <option value="auto">Auto (Recommended)</option>
                            <option value="none">None (CPU only)</option>
                            <option value="vaapi">VAAPI (Intel/AMD on Linux)</option>
                            <option value="qsv">Intel Quick Sync</option>
                            <option value="cuda">NVIDIA CUDA</option>
                            <option value="videotoolbox">VideoToolbox (Apple Silicon/macOS)</option>
                        </select>
                        <div class="fieldDescription">Hardware-accelerated video decoding for faster extraction. 'Auto' uses CPU decoding with automatic fallback - most compatible. Select specific hardware only if you know your system supports it.</div>
                    </div>

                    <h3 style="margin-top: 2em; margin-bottom: 1em; font-size: 1.1em; font-weight: 500;">Extraction LED Configuration</h3>
                    
                    <div class="fieldDescription" style="margin-bottom: 1em;">
                        These settings define the default LED layout used when extracting ambilight data from videos. The extracted binary files can be scaled to match different LED layouts when played back.
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1em; margin-bottom: 1em;">
                        <div class="inputContainer">
                            <label class="inputLabel inputLabelUnfocused" for="AmbilightTopLedCount">Top LED count</label>
                            <input id="AmbilightTopLedCount" type="number" is="emby-input" min="0" />
                        </div>
                        <div class="inputContainer">
                            <label class="inputLabel inputLabelUnfocused" for="AmbilightBottomLedCount">Bottom LED count</label>
                            <input id="AmbilightBottomLedCount" type="number" is="emby-input" min="0" />
                        </div>
                        <div class="inputContainer">
                            <label class="inputLabel inputLabelUnfocused" for="AmbilightLeftLedCount">Left LED count</label>
                            <input id="AmbilightLeftLedCount" type="number" is="emby-input" min="0" />
                        </div>
                        <div class="inputContainer">
                            <label class="inputLabel inputLabelUnfocused" for="AmbilightRightLedCount">Right LED count</label>
                            <input id="AmbilightRightLedCount" type="number" is="emby-input" min="0" />
                        </div>
                    </div>

                    <div class="checkboxContainer checkboxContainer-withDescription">
                        <label class="emby-checkbox-label">
                            <input id="AmbilightRgbw" type="checkbox" is="emby-checkbox" />
                            <span>Use RGBW format for extraction</span>
                        </label>
                        <div class="fieldDescription">Enable if your WLED controllers use RGBW (4-channel) LEDs instead of RGB (3-channel). This determines the format used when extracting ambilight data.</div>
                    </div>

                    <div class="inputContainer" style="margin-top: 1.5em;">
                        <label class="inputLabel inputLabelUnfocused" for="AmbilightDataFolder">Ambilight data folder</label>
                        <div style="display: flex; gap: 0.5em; align-items: center;">
                            <input id="AmbilightDataFolder" type="text" is="emby-input" placeholder="/data/ambilight" style="flex: 1;" />
                            <button type="button" id="btnBrowseDataFolder" is="emby-button" class="raised button-submit emby-button">Browse</button>
                        </div>
                        <div class="fieldDescription">Folder where binary files are stored (filenames: ItemId.bin). Use Browse to pick a folder.</div>
                    </div>
                    <div id="folderBrowserModal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6);">
                        <div style="max-width: 500px; margin: 2em auto; background: var(--bg); padding: 1.5em; border-radius: 8px;">
                            <h3 style="margin-top: 0;">Select folder</h3>
                            <div style="margin-bottom: 0.5em;">
                                <input type="text" id="folderBrowserPath" is="emby-input" style="margin-bottom: 0.5em;" placeholder="e.g. /data/ambilight" />
                            </div>
                            <div id="folderBrowserList" style="max-height: 300px; overflow-y: auto; margin-bottom: 1em;"></div>
                            <div style="display: flex; gap: 0.5em;">
                                <button type="button" id="folderBrowserSelect" is="emby-button" class="raised button-submit">Select this folder</button>
                                <button type="button" id="folderBrowserCancel" is="emby-button" class="raised">Cancel</button>
                            </div>
                        </div>
                    </div>

                    <h2 class="sectionTitle" style="margin-top: 2em;">WLED Device Mappings</h2>
                    
                    <div class="fieldDescription" style="margin-bottom: 1em;">
                        Map Jellyfin playback devices to WLED instances. Each mapping includes the LED layout configuration for that specific WLED controller. Only devices with at least one mapping will have ambilight effects.
                    </div>

                    <div id="deviceMappingsContainer" style="margin-bottom: 1em;"></div>

                    <button type="button" id="btnAddMapping" is="emby-button" class="raised button-submit emby-button" style="margin-bottom: 2em;">
                        Add Device Mapping
                    </button>

                    <h2 class="sectionTitle">Lightning Tuning</h2>

                    <div class="inputContainer">
                        <label class="inputLabel inputLabelUnfocused" for="AmbilightSmoothSeconds">Smoothing window (seconds)</label>
                        <input id="AmbilightSmoothSeconds" type="number" is="emby-input" step="0.01" />
                        <div class="fieldDescription">
                            Time window for temporal smoothing between frames, in seconds (default 0.12). Set to 0 to disable smoothing. Higher values = smoother but more delayed; lower values = more responsive but can flicker on rapid cuts.
                        </div>
                    </div>

                    <div class="inputContainer">
                        <label class="inputLabel inputLabelUnfocused" for="AmbilightGamma">Base gamma</label>
                        <input id="AmbilightGamma" type="number" is="emby-input" step="0.1" />
                        <div class="fieldDescription">
                            Overall gamma curve (default 2.2). Higher values make mid-tones and highlights darker and more contrasty; lower values make the image brighter but can wash out detail.
                        </div>
                    </div>

                    <div class="inputContainer">
                        <label class="inputLabel inputLabelUnfocused" for="AmbilightSaturation">Saturation</label>
                        <input id="AmbilightSaturation" type="number" is="emby-input" step="0.1" />
                        <div class="fieldDescription">
                            Color saturation multiplier (default 1.0). Higher values make colors more vivid; lower values make them more muted and neutral.
                        </div>
                    </div>

                    <div class="inputContainer">
                        <label class="inputLabel inputLabelUnfocused" for="AmbilightBrightnessTarget">Brightness target</label>
                        <input id="AmbilightBrightnessTarget" type="number" is="emby-input" step="1" />
                        <div class="fieldDescription">
                            Target average LED brightness (default 60). Higher values make the overall effect brighter; lower values dim the strip while still adapting per scene.
                        </div>
                    </div>

                    <div class="inputContainer">
                        <label class="inputLabel inputLabelUnfocused" for="AmbilightGammaRed">Red gamma</label>
                        <input id="AmbilightGammaRed" type="number" is="emby-input" step="0.1" />
                        <div class="fieldDescription">
                            Per‑channel gamma for red. Higher = darker reds; lower = brighter reds. Use to balance red against green/blue.
                        </div>
                    </div>

                    <div class="inputContainer">
                        <label class="inputLabel inputLabelUnfocused" for="AmbilightGammaGreen">Green gamma</label>
                        <input id="AmbilightGammaGreen" type="number" is="emby-input" step="0.1" />
                        <div class="fieldDescription">
                            Per‑channel gamma for green. Higher = darker greens; lower = brighter greens. Use to correct a green tint.
                        </div>
                    </div>

                    <div class="inputContainer">
                        <label class="inputLabel inputLabelUnfocused" for="AmbilightGammaBlue">Blue gamma</label>
                        <input id="AmbilightGammaBlue" type="number" is="emby-input" step="0.1" />
                        <div class="fieldDescription">
                            Per‑channel gamma for blue. Higher = darker blues; lower = brighter blues. Increase this if the image looks too blue.
                        </div>
                    </div>

                    <div class="inputContainer">
                        <label class="inputLabel inputLabelUnfocused" for="AmbilightRedBoost">Red boost</label>
                        <input id="AmbilightRedBoost" type="number" is="emby-input" step="0.1" />
                        <div class="fieldDescription">
                            Minimum floor for red when LEDs are dim (used with Min LED brightness). Higher values keep red visible in dark scenes; too high can tint blacks towards red.
                        </div>
                    </div>

                    <div class="inputContainer">
                        <label class="inputLabel inputLabelUnfocused" for="AmbilightGreenBoost">Green boost</label>
                        <input id="AmbilightGreenBoost" type="number" is="emby-input" step="0.1" />
                        <div class="fieldDescription">
                            Minimum floor for green when LEDs are dim. Higher values keep green present in shadows; too high can give a greenish cast to dark areas.
                        </div>
                    </div>

                    <div class="inputContainer">
                        <label class="inputLabel inputLabelUnfocused" for="AmbilightBlueBoost">Blue boost</label>
                        <input id="AmbilightBlueBoost" type="number" is="emby-input" step="0.1" />
                        <div class="fieldDescription">
                            Minimum floor for blue when LEDs are dim. Higher values keep blue visible in dark scenes; too high makes everything look cold/blue.
                        </div>
                    </div>

                    <div class="inputContainer">
                        <label class="inputLabel inputLabelUnfocused" for="AmbilightMinLedBrightness">Min LED brightness</label>
                        <input id="AmbilightMinLedBrightness" type="number" is="emby-input" step="0.1" />
                        <div class="fieldDescription">
                            Global minimum LED brightness (0 = true black). Higher values prevent LEDs from turning fully off, but combined with color boosts can introduce a color tint in very dark scenes.
                        </div>
                    </div>

                    <h2 class="sectionTitle" style="margin-top: 2em;">Debug</h2>

                    <div class="checkboxContainer checkboxContainer-withDescription">
                        <label class="emby-checkbox-label">
                            <input id="Debug" type="checkbox" is="emby-checkbox" />
                            <span>Enable debug logging</span>
                        </label>
                        <div class="fieldDescription">Log play/pause/seek, binary found/loaded, WLED connection and broadcast. Enable when troubleshooting why lights do not react.</div>
                    </div>

                    <div>
                        <button is="emby-button" type="submit" class="raised button-submit block emby-button">
                            <span>Save</span>
                        </button>
                    </div>
                </form>
                </div>

                <!-- Manager Tab -->
                <div id="managerTab" style="display: none;">
                    <h2 class="sectionTitle">Extraction Manager</h2>
                    <p class="sectionSubTitle">Manage ambilight data extraction for your video library</p>

                    <div style="display: flex; gap: 1em; margin-bottom: 1em; flex-wrap: wrap; align-items: center;">
                        <button id="btnRefresh" is="emby-button" class="raised button-submit">
                            <span class="material-icons" style="vertical-align: middle;">refresh</span>
                            Refresh
                        </button>
                        <button id="btnExtractAll" is="emby-button" class="raised button-submit">
                            <span class="material-icons" style="vertical-align: middle;">play_arrow</span>
                            Extract All Pending
                        </button>
                        <select id="typeFilter" is="emby-select" class="emby-select-withcolor emby-select" style="min-width: 120px;">
                            <option value="both">All Types</option>
                            <option value="series">Series Only</option>
                            <option value="movies">Movies Only</option>
                        </select>
                        <select id="statusFilter" is="emby-select" class="emby-select-withcolor emby-select" style="min-width: 120px;">
                            <option value="all">All Status</option>
                            <option value="extracted">Extracted</option>
                            <option value="pending">Pending</option>
                            <option value="failed">Failed</option>
                        </select>
                        <input id="searchBox" type="text" is="emby-input" placeholder="Search videos..." style="flex: 1; min-width: 200px;">
                    </div>

                    <div style="display: flex; gap: 2em; margin-bottom: 1em;">
                        <div style="padding: 0.5em;">
                            <span class="material-icons" style="color: #4ade80; vertical-align: middle;">check_circle</span>
                            <span id="statsExtracted">0</span> Extracted
                        </div>
                        <div style="padding: 0.5em;">
                            <span class="material-icons" style="color: #fbbf24; vertical-align: middle;">pending</span>
                            <span id="statsPending">0</span> Pending
                        </div>
                        <div style="padding: 0.5em;">
                            <span class="material-icons" style="color: #ef4444; vertical-align: middle;">error</span>
                            <span id="statsFailed">0</span> Failed
                        </div>
                    </div>

                    <div id="loadingMessage" style="text-align: center; padding: 2em;">
                        <p>Loading library...</p>
                    </div>

                    <div id="videoList" style="display: none;">
                        <table class="tblLibrary" style="width: 100%;">
                            <thead>
                                <tr>
                                    <th>Title</th>
                                    <th>Added Date</th>
                                    <th>Status</th>
                                    <th>Size</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody id="videoTableBody">
                            </tbody>
                        </table>
                    </div>
                </div>

            </div>
        </div>
        <script type="text/javascript">
            var AmbilightConfig = {
                pluginUniqueId: 'b3f6b4c7-0a3d-4bd4-a7e3-c8d5a0a1e3f0',
                currentConfig: null
            };

            document.querySelector('#AmbilightConfigPage')
                .addEventListener('pageshow', function() {
                    Dashboard.showLoadingMsg();
                    ApiClient.getPluginConfiguration(AmbilightConfig.pluginUniqueId).then(function (config) {
                        AmbilightConfig.currentConfig = config;
                        document.querySelector('#ExtractNewlyAddedItems').checked = config.ExtractNewlyAddedItems !== false;
                        document.querySelector('#ExtractionPriority').value = config.ExtractionPriority || 'newest_first';
                        document.querySelector('#HardwareAcceleration').value = config.HardwareAcceleration || 'auto';
                        document.querySelector('#AmbilightDataFolder').value = config.AmbilightDataFolder || '/data/ambilight';
                        document.querySelector('#AmbilightSmoothSeconds').value = (config.AmbilightSmoothSeconds != null ? config.AmbilightSmoothSeconds : 0.12);
                        document.querySelector('#Debug').checked = config.Debug === true;

                        // Extraction LED configuration
                        document.querySelector('#AmbilightTopLedCount').value = config.AmbilightTopLedCount;
                        document.querySelector('#AmbilightBottomLedCount').value = config.AmbilightBottomLedCount;
                        document.querySelector('#AmbilightLeftLedCount').value = config.AmbilightLeftLedCount;
                        document.querySelector('#AmbilightRightLedCount').value = config.AmbilightRightLedCount;
                        document.querySelector('#AmbilightRgbw').checked = config.AmbilightRgbw;
                        document.querySelector('#AmbilightGamma').value = config.AmbilightGamma;
                        document.querySelector('#AmbilightSaturation').value = config.AmbilightSaturation;
                        document.querySelector('#AmbilightBrightnessTarget').value = config.AmbilightBrightnessTarget;

                        // Per-channel gamma and boosts
                        document.querySelector('#AmbilightGammaRed').value = config.AmbilightGammaRed;
                        document.querySelector('#AmbilightGammaGreen').value = config.AmbilightGammaGreen;
                        document.querySelector('#AmbilightGammaBlue').value = config.AmbilightGammaBlue;
                        document.querySelector('#AmbilightRedBoost').value = config.AmbilightRedBoost;
                        document.querySelector('#AmbilightGreenBoost').value = config.AmbilightGreenBoost;
                        document.querySelector('#AmbilightBlueBoost').value = config.AmbilightBlueBoost;
                        document.querySelector('#AmbilightMinLedBrightness').value = config.AmbilightMinLedBrightness;

                        // Populate excluded libraries and device list for mappings
                        loadLibraries(config);
                        loadAvailableDevices().then(function() {
                            loadDeviceMappings(config);
                        });

                        Dashboard.hideLoadingMsg();
                    });
                });

            document.querySelector('#AmbilightConfigForm')
                .addEventListener('submit', function(e) {
                Dashboard.showLoadingMsg();
                ApiClient.getPluginConfiguration(AmbilightConfig.pluginUniqueId).then(function (config) {
                    config.ExtractNewlyAddedItems = document.querySelector('#ExtractNewlyAddedItems').checked;
                    config.ExtractionPriority = document.querySelector('#ExtractionPriority').value;
                    config.HardwareAcceleration = document.querySelector('#HardwareAcceleration').value || 'auto';
                    config.AmbilightDataFolder = document.querySelector('#AmbilightDataFolder').value || '/data/ambilight';
                    config.AmbilightSmoothSeconds = parseFloat(document.querySelector('#AmbilightSmoothSeconds').value || '0.12');
                    config.Debug = document.querySelector('#Debug').checked === true;

                    // Extraction LED configuration
                    config.AmbilightTopLedCount = document.querySelector('#AmbilightTopLedCount').value;
                    config.AmbilightBottomLedCount = document.querySelector('#AmbilightBottomLedCount').value;
                    config.AmbilightLeftLedCount = document.querySelector('#AmbilightLeftLedCount').value;
                    config.AmbilightRightLedCount = document.querySelector('#AmbilightRightLedCount').value;
                    config.AmbilightRgbw = document.querySelector('#AmbilightRgbw').checked;
                    config.AmbilightGamma = document.querySelector('#AmbilightGamma').value;
                    config.AmbilightSaturation = document.querySelector('#AmbilightSaturation').value;
                    config.AmbilightBrightnessTarget = document.querySelector('#AmbilightBrightnessTarget').value;

                    config.AmbilightGammaRed = document.querySelector('#AmbilightGammaRed').value;
                    config.AmbilightGammaGreen = document.querySelector('#AmbilightGammaGreen').value;
                    config.AmbilightGammaBlue = document.querySelector('#AmbilightGammaBlue').value;
                    config.AmbilightRedBoost = document.querySelector('#AmbilightRedBoost').value;
                    config.AmbilightGreenBoost = document.querySelector('#AmbilightGreenBoost').value;
                    config.AmbilightBlueBoost = document.querySelector('#AmbilightBlueBoost').value;
                    config.AmbilightMinLedBrightness = document.querySelector('#AmbilightMinLedBrightness').value;

                    // Device mappings
                    config.DeviceMappings = collectDeviceMappings();

                    // Excluded libraries
                    var excluded = [];
                    var libSelect = document.getElementById('ExcludedLibraries');
                    if (libSelect) {
                        for (var i = 0; i < libSelect.options.length; i++) {
                            var opt = libSelect.options[i];
                            if (opt.selected && opt.value) {
                                excluded.push(opt.value);
                            }
                        }
                    }
                    config.ExcludedLibraryIds = excluded;

                    ApiClient.updatePluginConfiguration(AmbilightConfig.pluginUniqueId, config).then(function (result) {
                        Dashboard.processPluginConfigurationUpdateResult(result);
                    });
                });

                e.preventDefault();
                return false;
            });

            // ===== FOLDER BROWSER (Storage path) – same behaviour as Jellyfin library path picker =====
            (function () {
                var modal = document.getElementById('folderBrowserModal');
                var pathInput = document.getElementById('folderBrowserPath');
                var listEl = document.getElementById('folderBrowserList');
                var dataFolderInput = document.getElementById('AmbilightDataFolder');
                var currentBrowsePath = '';

                function addRow(name, fullPath, isParent) {
                    var row = document.createElement('div');
                    row.style.cssText = 'padding: 0.5em; cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center;';
                    if (isParent) {
                        row.innerHTML = '<span class="material-icons" style="margin-right: 0.5em; font-size: 1.2em;">drive_file_move</span><strong>' + (name || '..') + '</strong>';
                    } else {
                        row.innerHTML = '<span class="material-icons" style="margin-right: 0.5em; font-size: 1.2em;">folder</span>' + (name || fullPath);
                    }
                    row.title = fullPath || name;
                    row.addEventListener('click', function () {
                        currentBrowsePath = fullPath || name;
                        pathInput.value = currentBrowsePath;
                        loadDirectoryContents(currentBrowsePath);
                    });
                    listEl.appendChild(row);
                }

                function loadDirectoryContents(path) {
                    listEl.innerHTML = '<p>Loading...</p>';
                    currentBrowsePath = path || '';

                    if (!path || path === '') {
                        pathInput.value = '';
                        var drivesUrl = ApiClient.getUrl('Environment/Drives');
                        ApiClient.getJSON(drivesUrl).then(function (entries) {
                            listEl.innerHTML = '';
                            if (!entries || entries.length === 0) {
                                listEl.appendChild(document.createTextNode('No drives found. Type the path above (e.g. /data/ambilight) and click Select this folder.'));
                                return;
                            }
                            entries.forEach(function (e) {
                                var name = e.Name || e.Path || '';
                                var fullPath = e.Path || name;
                                if (!fullPath) return;
                                addRow(name, fullPath, false);
                            });
                        }).catch(function (err) {
                            listEl.innerHTML = '';
                            listEl.appendChild(document.createTextNode('Could not load drives. Type the path above (e.g. /data/ambilight) and click Select.'));
                        });
                        return;
                    }

                    pathInput.value = path;
                    listEl.innerHTML = '';
                    var parentUrl = ApiClient.getUrl('Environment/ParentPath', { path: path });
                    var contentsUrl = ApiClient.getUrl('Environment/DirectoryContents', { path: path, includeFiles: false, includeDirectories: true });
                    var parentPromise = ApiClient.getJSON(parentUrl).catch(function () { return null; });
                    var contentsPromise = ApiClient.getJSON(contentsUrl);
                    Promise.all([parentPromise, contentsPromise]).then(function (results) {
                        var parentPath = results[0];
                        var entries = results[1];
                        if (parentPath != null && parentPath !== '') {
                            addRow('.. (Parent)', parentPath, true);
                        }
                        if (!entries || entries.length === 0) {
                            if (listEl.children.length === 0) {
                                listEl.appendChild(document.createTextNode('(empty folder – you can still select this path)'));
                            }
                            return;
                        }
                        entries.forEach(function (e) {
                            var isDir = e.Type === 'Directory' || e.IsDirectory === true;
                            if (!isDir) return;
                            var name = e.Name || e.Path || '';
                            var fullPath = e.Path || (path.replace(/\/?$/, '') + '/' + name);
                            if (!name) return;
                            addRow(name, fullPath, false);
                        });
                    }).catch(function (err) {
                        listEl.innerHTML = '';
                        listEl.appendChild(document.createTextNode('Cannot list folder (e.g. permissions). Type or paste the path above and click Select this folder.'));
                    });
                }

                document.getElementById('btnBrowseDataFolder').addEventListener('click', function () {
                    currentBrowsePath = (dataFolderInput.value || '').trim() || '';
                    pathInput.value = currentBrowsePath || '';
                    modal.style.display = 'block';
                    if (currentBrowsePath) {
                        loadDirectoryContents(currentBrowsePath);
                    } else {
                        loadDirectoryContents('');
                    }
                });

                document.getElementById('folderBrowserSelect').addEventListener('click', function () {
                    dataFolderInput.value = (pathInput.value || currentBrowsePath || '').trim() || '/data/ambilight';
                    modal.style.display = 'none';
                });

                document.getElementById('folderBrowserCancel').addEventListener('click', function () {
                    modal.style.display = 'none';
                });

                modal.addEventListener('click', function (e) {
                    if (e.target === modal) modal.style.display = 'none';
                });
            })();

            // ===== MANAGER TAB LOGIC ===== v1.3.0 - Batch API
            console.log('[Ambilight] Config v1.3.0 - Batch API Implementation');
            
            let allVideos = [];
            let currentFilter = '';
            let currentStatusFilter = 'all';
            let currentTypeFilter = 'both';
            let extractingIds = {};
            let pollingInterval = null;
            
            // Track expanded/collapsed state to preserve user's tree view
            let expandedSeries = new Set();  // Series IDs that are expanded
            let expandedSeasons = new Set(); // Season IDs (seriesId-seasonNum) that are expanded

            function showToast(msg) {
                if (typeof require === 'function') {
                    try {
                        require(['toast'], function(toast) { toast(msg); });
                    } catch (e) {
                        if (typeof alert !== 'undefined') alert(msg); else console.log(msg);
                    }
                } else {
                    if (typeof alert !== 'undefined') alert(msg); else console.log(msg);
                }
            }

            function loadLibraries(config) {
                var select = document.getElementById('ExcludedLibraries');
                if (!select) return;

                ApiClient.getUserViews(ApiClient.getCurrentUserId()).then(function (result) {
                    select.innerHTML = '';
                    var items = (result && result.Items) || [];
                    var excluded = config.ExcludedLibraryIds || [];

                    items.forEach(function (view) {
                        var opt = document.createElement('option');
                        opt.value = view.Id;
                        opt.textContent = view.Name;
                        if (excluded.indexOf(view.Id) !== -1) {
                            opt.selected = true;
                        }
                        select.appendChild(opt);
                    });
                }).catch(function (e) {
                    console.log('[Ambilight] Failed to load libraries', e);
                });
            }

            function loadAvailableDevices() {
                // Store devices globally for device mappings
                window.AmbilightAvailableDevices = [];

                // Load all known devices from Jellyfin
                try {
                    var url = ApiClient.getUrl('Devices');
                    return ApiClient.getJSON(url).then(function (devices) {
                        if (!devices) {
                            return;
                        }
                        var list = devices.Items || devices; // handle both { Items: [] } and [] shapes
                        (list || []).forEach(function (d) {
                            var deviceId = d.Id || d.DeviceId;
                            if (!deviceId) {
                                return;
                            }
                            var name = d.Name || d.DeviceName || d.AppName || deviceId;
                            
                            // Store for device mappings
                            window.AmbilightAvailableDevices.push({
                                id: deviceId,
                                name: name
                            });
                        });
                    }).catch(function (e) {
                        console.log('[Ambilight] Failed to load Devices API list', e);
                    });
                } catch (e) {
                    console.log('[Ambilight] Error building Devices API URL', e);
                    return Promise.resolve();
                }
            }

            // Device Mappings Management
            function loadDeviceMappings(config) {
                var container = document.getElementById('deviceMappingsContainer');
                if (!container) return;
                
                container.innerHTML = '';
                var mappings = config.DeviceMappings || [];
                
                if (mappings.length === 0) {
                    container.innerHTML = '<p style="color: rgba(255,255,255,0.5);">No device mappings configured. Click "Add Device Mapping" to create one.</p>';
                }
                
                mappings.forEach(function(mapping, index) {
                    addMappingRow(container, mapping, index);
                });
            }
            
            function addMappingRow(container, mapping, index) {
                var wrapper = document.createElement('div');
                wrapper.style.cssText = 'margin-bottom: 1.5em; padding: 1em; background: rgba(255,255,255,0.05); border-radius: 8px; border-left: 3px solid var(--theme-primary-color);';
                wrapper.setAttribute('data-mapping-index', index);
                
                // Header row with device, host, port, remove
                var headerRow = document.createElement('div');
                headerRow.style.cssText = 'display: flex; gap: 0.5em; align-items: center; margin-bottom: 1em;';
                
                // Create device select dropdown
                var deviceSelect = document.createElement('select');
                deviceSelect.className = 'mapping-device emby-select-withcolor emby-select';
                deviceSelect.setAttribute('is', 'emby-select');
                deviceSelect.style.cssText = 'flex: 2;';
                
                // Add placeholder option
                var placeholderOpt = document.createElement('option');
                placeholderOpt.value = '';
                placeholderOpt.textContent = '-- Select a device --';
                placeholderOpt.disabled = true;
                placeholderOpt.selected = !mapping.DeviceIdentifier;
                deviceSelect.appendChild(placeholderOpt);
                
                // Populate with available devices
                if (window.AmbilightAvailableDevices && window.AmbilightAvailableDevices.length > 0) {
                    window.AmbilightAvailableDevices.forEach(function(device) {
                        var opt = document.createElement('option');
                        opt.value = device.id;
                        opt.textContent = device.name;
                        if (mapping.DeviceIdentifier === device.id) {
                            opt.selected = true;
                        }
                        deviceSelect.appendChild(opt);
                    });
                }
                
                headerRow.appendChild(deviceSelect);
                
                // Create host input
                var hostInput = document.createElement('input');
                hostInput.type = 'text';
                hostInput.className = 'mapping-host emby-input';
                hostInput.setAttribute('is', 'emby-input');
                hostInput.placeholder = 'WLED host or IP';
                hostInput.value = mapping.Host || '';
                hostInput.style.cssText = 'flex: 2;';
                headerRow.appendChild(hostInput);
                
                // Create port input
                var portInput = document.createElement('input');
                portInput.type = 'number';
                portInput.className = 'mapping-port emby-input';
                portInput.setAttribute('is', 'emby-input');
                portInput.placeholder = '19446';
                portInput.value = mapping.Port || 19446;
                portInput.min = '1';
                portInput.max = '65535';
                portInput.style.cssText = 'flex: 1; max-width: 100px;';
                headerRow.appendChild(portInput);
                
                // Create remove button
                var removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'btnRemoveMapping raised button-cancel emby-button';
                removeBtn.setAttribute('is', 'emby-button');
                removeBtn.style.cssText = 'min-width: 80px;';
                removeBtn.textContent = 'Remove';
                removeBtn.addEventListener('click', function() {
                    wrapper.remove();
                });
                headerRow.appendChild(removeBtn);
                
                wrapper.appendChild(headerRow);
                
                // LED Configuration section for this mapping
                var ledConfig = document.createElement('div');
                ledConfig.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.75em; padding-top: 0.75em; border-top: 1px solid rgba(255,255,255,0.1);';
                
                ledConfig.innerHTML = `
                    <div>
                        <label style="display: block; margin-bottom: 0.25em; font-size: 0.9em; opacity: 0.8;">Top LEDs</label>
                        <input type="number" class="mapping-top emby-input" min="0" is="emby-input" />
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 0.25em; font-size: 0.9em; opacity: 0.8;">Bottom LEDs</label>
                        <input type="number" class="mapping-bottom emby-input" min="0" is="emby-input" />
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 0.25em; font-size: 0.9em; opacity: 0.8;">Left LEDs</label>
                        <input type="number" class="mapping-left emby-input" min="0" is="emby-input" />
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 0.25em; font-size: 0.9em; opacity: 0.8;">Right LEDs</label>
                        <input type="number" class="mapping-right emby-input" min="0" is="emby-input" />
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 0.25em; font-size: 0.9em; opacity: 0.8;">Input Position</label>
                        <input type="number" class="mapping-input-pos emby-input" min="0" is="emby-input" />
                    </div>
                `;
                
                wrapper.appendChild(ledConfig);
                container.appendChild(wrapper);
                
                // Set values after elements are added to DOM (required for Jellyfin inputs)
                wrapper.querySelector('.mapping-top').value = mapping.TopLedCount || 89;
                wrapper.querySelector('.mapping-bottom').value = mapping.BottomLedCount || 89;
                wrapper.querySelector('.mapping-left').value = mapping.LeftLedCount || 49;
                wrapper.querySelector('.mapping-right').value = mapping.RightLedCount || 49;
                wrapper.querySelector('.mapping-input-pos').value = mapping.InputPosition || 0;
            }
            
            document.getElementById('btnAddMapping').addEventListener('click', function() {
                var container = document.getElementById('deviceMappingsContainer');
                if (!container) return;
                
                // Clear placeholder message if present
                var placeholder = container.querySelector('p');
                if (placeholder) {
                    placeholder.remove();
                }
                
                var index = container.children.length;
                addMappingRow(container, { DeviceIdentifier: '', Host: '', Port: 19446 }, index);
            });
            
            function collectDeviceMappings() {
                var container = document.getElementById('deviceMappingsContainer');
                if (!container) return [];
                
                var mappings = [];
                var rows = container.querySelectorAll('[data-mapping-index]');
                var seen = new Set(); // Track device+host+port combinations
                
                rows.forEach(function(row) {
                    var deviceSelect = row.querySelector('.mapping-device');
                    var device = deviceSelect.value.trim();
                    var host = row.querySelector('.mapping-host').value.trim();
                    var port = parseInt(row.querySelector('.mapping-port').value) || 19446;
                    
                    if (device && host) {
                        var key = device.toLowerCase() + '|' + host.toLowerCase() + '|' + port;
                        
                        if (seen.has(key)) {
                            var deviceName = deviceSelect.options[deviceSelect.selectedIndex].textContent;
                            showToast('Warning: Duplicate mapping ignored - Device "' + deviceName + '" → ' + host + ':' + port + ' appears multiple times');
                        } else {
                            mappings.push({
                                DeviceIdentifier: device,
                                Host: host,
                                Port: port,
                                TopLedCount: parseInt(row.querySelector('.mapping-top').value) || 89,
                                BottomLedCount: parseInt(row.querySelector('.mapping-bottom').value) || 89,
                                LeftLedCount: parseInt(row.querySelector('.mapping-left').value) || 49,
                                RightLedCount: parseInt(row.querySelector('.mapping-right').value) || 49,
                                InputPosition: parseInt(row.querySelector('.mapping-input-pos').value) || 0
                            });
                            seen.add(key);
                        }
                    }
                });
                
                return mappings;
            }

            // Tab switching
            document.getElementById('tabSelector').addEventListener('change', function(e) {
                const tab = e.target.value;
                if (tab === 'settings') {
                    document.getElementById('settingsTab').style.display = 'block';
                    document.getElementById('managerTab').style.display = 'none';
                    stopPolling(); // Stop polling when leaving manager tab
                } else {
                    document.getElementById('settingsTab').style.display = 'none';
                    document.getElementById('managerTab').style.display = 'block';
                    if (allVideos.length === 0) {
                        loadLibrary();
                    }
                }
            });

            async function loadLibrary() {
                console.log('[Ambilight] loadLibrary() called');
                try {
                    Dashboard.showLoadingMsg();

                    // Get excluded libraries from config
                    var cfg = AmbilightConfig.currentConfig || {};
                    var excludedLibs = cfg.ExcludedLibraryIds || [];
                    console.log('[Ambilight] Excluded library IDs:', excludedLibs);

                    // Normalize function for comparison
                    function normalizeId(id) {
                        return (id || '').toLowerCase().replace(/-/g, '');
                    }

                    var normalizedExcluded = excludedLibs.map(normalizeId);

                    // Get all libraries first
                    var libraries = await ApiClient.getUserViews(ApiClient.getCurrentUserId());
                    var allLibraries = (libraries && libraries.Items) || [];
                    console.log('[Ambilight] All libraries:', allLibraries.map(l => ({ Id: l.Id, Name: l.Name })));

                    // Filter to only allowed libraries (video libraries, not excluded)
                    var allowedLibraries = allLibraries.filter(function(lib) {
                        var libId = normalizeId(lib.Id);
                        var isExcluded = normalizedExcluded.indexOf(libId) !== -1;
                        console.log('[Ambilight] Library:', lib.Name, 'ID:', lib.Id, 'Excluded:', isExcluded);
                        return !isExcluded && (lib.CollectionType === 'movies' || lib.CollectionType === 'tvshows');
                    });

                    console.log('[Ambilight] Allowed libraries:', allowedLibraries.map(l => ({ Id: l.Id, Name: l.Name })));

                    // Fetch items from each allowed library
                    allVideos = [];
                    for (var i = 0; i < allowedLibraries.length; i++) {
                        var lib = allowedLibraries[i];
                        const query = {
                            ParentId: lib.Id,
                            IncludeItemTypes: 'Movie,Episode',
                            Recursive: true,
                            Fields: 'Path,DateCreated,SeriesName,SeasonName,ParentIndexNumber,IndexNumber,Type,ParentId,SeriesId',
                            SortBy: 'SortName',
                            SortOrder: 'Ascending'
                        };

                        const result = await ApiClient.getItems(ApiClient.getCurrentUserId(), query);
                        var items = result.Items || [];
                        console.log('[Ambilight] Loaded', items.length, 'items from library:', lib.Name);
                        allVideos = allVideos.concat(items);
                    }

                    console.log('[Ambilight] Total videos loaded:', allVideos.length);

                    // ===== BATCH API REQUEST - v1.3.0 =====
                    console.log('[Ambilight] Fetching status for', allVideos.length, 'videos in batch');
                    
                    try {
                        const videoIds = allVideos.map(function(v) { return v.Id; });
                        const response = await fetch('/Ambilight/Status/Batch', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify(videoIds)
                        });
                        
                        if (response.ok) {
                            const statuses = await response.json();
                            
                            allVideos.forEach(function(video) {
                                if (statuses[video.Id]) {
                                    video.ambilightStatus = statuses[video.Id];
                                    
                                    // Track extracting videos for polling
                                    if (video.ambilightStatus.ExtractionStatus === 'extracting') {
                                        extractingIds[video.Id] = true;
                                    }
                                } else {
                                    video.ambilightStatus = { HasBinary: false, BinarySize: 0, ExtractionStatus: 'pending' };
                                }
                            });
                            
                            console.log('[Ambilight] Batch status loaded successfully, extracting videos:', Object.keys(extractingIds).length);
                            
                            // Start polling if there are extracting videos
                            if (Object.keys(extractingIds).length > 0) {
                                startPolling();
                            }
                        } else {
                            console.error('[Ambilight] Batch status fetch failed:', response.status);
                            allVideos.forEach(function(video) {
                                video.ambilightStatus = { HasBinary: false, BinarySize: 0, ExtractionStatus: 'pending' };
                            });
                        }
                    } catch (e) {
                        console.error('[Ambilight] Batch status error:', e);
                        allVideos.forEach(function(video) {
                            video.ambilightStatus = { HasBinary: false, BinarySize: 0, ExtractionStatus: 'pending' };
                        });
                    }

                    console.log('[Ambilight] All videos loaded:', allVideos.length);

                    // Sort by DateCreated, newest first
                    allVideos.sort(function(a, b) {
                        var dateA = a.DateCreated ? new Date(a.DateCreated) : new Date(0);
                        var dateB = b.DateCreated ? new Date(b.DateCreated) : new Date(0);
                        return dateB - dateA; // Descending (newest first)
                    });

                    // Clear extracting flags for items that have finished (either extracted or failed)
                    allVideos.forEach(function (video) {
                        var status = video.ambilightStatus;
                        if (status && (status.HasBinary || status.error)) {
                            if (extractingIds[video.Id]) {
                                delete extractingIds[video.Id];
                            }
                        }
                    });

                    updateStatistics();
                    renderVideoList();

                    document.getElementById('loadingMessage').style.display = 'none';
                    document.getElementById('videoList').style.display = 'block';

                    Dashboard.hideLoadingMsg();
                } catch (error) {
                    console.error('Error loading library:', error);
                    Dashboard.hideLoadingMsg();
                    showToast('Failed to load library: ' + error.message);
                }
            }

            function updateStatistics() {
                const extracted = allVideos.filter(v => v.ambilightStatus?.HasBinary).length;
                const failed = allVideos.filter(v => v.ambilightStatus?.ExtractionStatus === 'failed').length;
                const pending = allVideos.length - extracted - failed;

                document.getElementById('statsExtracted').textContent = extracted;
                document.getElementById('statsPending').textContent = pending;
                document.getElementById('statsFailed').textContent = failed;
            }

            function escapeHtml(text) {
                if (text == null) return '';
                var div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            function renderVideoList() {
                const tbody = document.getElementById('videoTableBody');
                tbody.innerHTML = '';

                const filteredVideos = allVideos.filter(function(video) {
                    // Filter by type
                    var type = video.Type || '';
                    if (currentTypeFilter === 'series' && type !== 'Episode') return false;
                    if (currentTypeFilter === 'movies' && type === 'Episode') return false;

                    // Filter by search text
                    if (currentFilter) {
                        var searchLower = currentFilter.toLowerCase();
                        var matchesName = (video.Name || '').toLowerCase().indexOf(searchLower) !== -1;
                        var matchesSeries = (video.SeriesName || '').toLowerCase().indexOf(searchLower) !== -1;
                        if (!matchesName && !matchesSeries) {
                            return false;
                        }
                    }

                    // Filter by status
                    if (currentStatusFilter !== 'all') {
                        var status = video.ambilightStatus;
                        var hasExtracted = !!(status && status.HasBinary);
                        var hasFailed = !!(status && status.error);
                        var isPending = !hasExtracted && !hasFailed;

                        if (currentStatusFilter === 'extracted' && !hasExtracted) return false;
                        if (currentStatusFilter === 'failed' && !hasFailed) return false;
                        if (currentStatusFilter === 'pending' && !isPending) return false;
                    }

                    return true;
                });

                // Group episodes by series and season (3-level hierarchy: Series → Season → Episodes)
                var groupedData = {};
                var movies = [];
                
                filteredVideos.forEach(function(video) {
                    var type = video.Type || '';
                    if (type === 'Episode') {
                        var seriesName = video.SeriesName || 'Unknown Series';
                        var seriesId = video.SeriesId || 'unknown';
                        var seasonNumber = video.ParentIndexNumber != null ? video.ParentIndexNumber : 0;
                        
                        if (!groupedData[seriesId]) {
                            groupedData[seriesId] = {
                                name: seriesName,
                                seasons: {},
                                newestEpisodeDate: null
                            };
                        }
                        
                        if (!groupedData[seriesId].seasons[seasonNumber]) {
                            groupedData[seriesId].seasons[seasonNumber] = [];
                        }
                        
                        groupedData[seriesId].seasons[seasonNumber].push(video);
                        
                        // Track newest episode date for sorting
                        if (video.DateCreated) {
                            var episodeDate = new Date(video.DateCreated);
                            if (!groupedData[seriesId].newestEpisodeDate || episodeDate > groupedData[seriesId].newestEpisodeDate) {
                                groupedData[seriesId].newestEpisodeDate = episodeDate;
                            }
                        }
                    } else {
                        movies.push(video);
                    }
                });

                // Create mixed list of series and movies with sort dates
                var mixedItems = [];
                
                // Add series with their newest episode date
                Object.keys(groupedData).forEach(function(seriesId) {
                    var series = groupedData[seriesId];
                    mixedItems.push({
                        type: 'series',
                        id: seriesId,
                        data: series,
                        sortDate: series.newestEpisodeDate || new Date(0)
                    });
                });
                
                // Add movies with their DateCreated
                movies.forEach(function(movie) {
                    mixedItems.push({
                        type: 'movie',
                        data: movie,
                        sortDate: movie.DateCreated ? new Date(movie.DateCreated) : new Date(0)
                    });
                });
                
                // Sort by date, newest first
                mixedItems.sort(function(a, b) {
                    return b.sortDate - a.sortDate;
                });

                // Render mixed items in sorted order
                mixedItems.forEach(function(item) {
                    if (item.type === 'series') {
                        var seriesId = item.id;
                        var series = item.data;
                        var seasonKeys = Object.keys(series.seasons).sort(function(a, b) { return parseInt(a) - parseInt(b); });

                        // Calculate series-level stats (all episodes across all seasons)
                        var allEpisodes = [];
                        seasonKeys.forEach(function(seasonNum) {
                            allEpisodes = allEpisodes.concat(series.seasons[seasonNum]);
                        });
                        var seriesExtractedCount = allEpisodes.filter(function(e) { return e.ambilightStatus?.HasBinary; }).length;
                        var seriesFailedCount = allEpisodes.filter(function(e) { return e.ambilightStatus?.error; }).length;
                        var seriesPendingCount = allEpisodes.length - seriesExtractedCount - seriesFailedCount;
                        
                        // Determine series status
                        var seriesStatusIcon = 'pending';
                        var seriesStatusText = 'Pending';
                        var seriesStatusColor = '#fbbf24';
                        
                        if (seriesFailedCount > 0) {
                            // Failed: if ANY extraction failed
                            seriesStatusIcon = 'error';
                            seriesStatusText = 'Failed';
                            seriesStatusColor = '#ef4444';
                        } else if (seriesPendingCount === 0 && seriesExtractedCount === allEpisodes.length) {
                            // Extracted: if ALL episodes have been extracted
                            seriesStatusIcon = 'check_circle';
                            seriesStatusText = 'Extracted';
                            seriesStatusColor = '#4ade80';
                        } else {
                            // Pending: if there are some episodes extracted but some pending
                            seriesStatusIcon = 'pending';
                            seriesStatusText = 'Pending';
                            seriesStatusColor = '#fbbf24';
                        }
                        
                        // Series header row (level 1)
                        var seriesRow = document.createElement('tr');
                        seriesRow.className = 'series-header';
                        seriesRow.style.backgroundColor = 'rgba(255, 255, 255, 0.08)';
                        seriesRow.style.cursor = 'pointer';
                        seriesRow.style.fontWeight = 'bold';
                        seriesRow.style.fontSize = '1.05em';
                        
                        var seriesCollapsedId = 'series-' + seriesId;
                        // Use session state (not localStorage for persistence)
                        var isSeriesCollapsed = !expandedSeries.has(seriesId);
                        var seriesExpandIcon = isSeriesCollapsed ? 'chevron_right' : 'expand_more';
                        var seriesStatusHtml = '<span class="material-icons" style="color:' + seriesStatusColor + ';vertical-align:middle;font-size:1.1em;margin-left:0.5em;">' + seriesStatusIcon + '</span><span style="color:' + seriesStatusColor + ';margin-left:0.3em;font-weight:normal;font-size:0.95em;">' + seriesStatusText + '</span>';
                        var seriesStatsHtml = '<span style="font-weight: normal; font-size: 0.9em; opacity: 0.8;"> (' + seasonKeys.length + ' seasons, ' + allEpisodes.length + ' episodes: ' + seriesExtractedCount + ' extracted, ' + seriesPendingCount + ' pending' + (seriesFailedCount > 0 ? ', ' + seriesFailedCount + ' failed' : '') + ')</span>';
                        
                        seriesRow.innerHTML = '<td colspan="5"><span class="material-icons" style="vertical-align: middle; font-size: 1.2em;">' + seriesExpandIcon + '</span> ' + 
                            escapeHtml(series.name) + seriesStatusHtml + seriesStatsHtml + '</td>';
                        seriesRow.setAttribute('data-series-id', seriesCollapsedId);
                        seriesRow.setAttribute('data-collapsed', isSeriesCollapsed ? 'true' : 'false');
                        
                        tbody.appendChild(seriesRow);

                        // Season header rows (level 2) and episode rows (level 3)
                        seasonKeys.forEach(function(seasonNumber) {
                            var episodes = series.seasons[seasonNumber];
                            var seasonName = 'Season ' + seasonNumber;

                            // Calculate season stats
                            var extractedCount = episodes.filter(function(e) { return e.ambilightStatus?.HasBinary; }).length;
                            var failedCount = episodes.filter(function(e) { return e.ambilightStatus?.error; }).length;
                            var pendingCount = episodes.length - extractedCount - failedCount;
                            
                            // Determine season status
                            var seasonStatusIcon = 'pending';
                            var seasonStatusText = 'Pending';
                            var seasonStatusColor = '#fbbf24';
                            
                            if (failedCount > 0) {
                                seasonStatusIcon = 'error';
                                seasonStatusText = 'Failed';
                                seasonStatusColor = '#ef4444';
                            } else if (pendingCount === 0 && extractedCount === episodes.length) {
                                seasonStatusIcon = 'check_circle';
                                seasonStatusText = 'Extracted';
                                seasonStatusColor = '#4ade80';
                            } else {
                                seasonStatusIcon = 'pending';
                                seasonStatusText = 'Pending';
                                seasonStatusColor = '#fbbf24';
                            }
                            
                            // Season header row (level 2)
                            var seasonRow = document.createElement('tr');
                            seasonRow.className = 'season-header';
                            seasonRow.style.backgroundColor = 'rgba(255, 255, 255, 0.04)';
                            seasonRow.style.cursor = 'pointer';
                            seasonRow.style.fontWeight = 'bold';
                            seasonRow.style.display = isSeriesCollapsed ? 'none' : '';
                            seasonRow.setAttribute('data-parent-series', seriesCollapsedId);
                            
                            var seasonId = 'season-' + seriesId + '-' + seasonNumber;
                            // Use session state (not localStorage for persistence)
                            var isSeasonCollapsed = !expandedSeasons.has(seasonId);
                            var seasonExpandIcon = isSeasonCollapsed ? 'chevron_right' : 'expand_more';
                            var seasonStatusHtml = '<span class="material-icons" style="color:' + seasonStatusColor + ';vertical-align:middle;font-size:1em;margin-left:0.5em;">' + seasonStatusIcon + '</span><span style="color:' + seasonStatusColor + ';margin-left:0.3em;font-weight:normal;font-size:0.9em;">' + seasonStatusText + '</span>';
                            var seasonStatsHtml = '<span style="font-weight: normal; font-size: 0.9em; opacity: 0.8;"> (' + episodes.length + ' episodes: ' + extractedCount + ' extracted, ' + pendingCount + ' pending' + (failedCount > 0 ? ', ' + failedCount + ' failed' : '') + ')</span>';
                            
                            seasonRow.innerHTML = '<td colspan="5"><span style="padding-left: 1.5em;"><span class="material-icons" style="vertical-align: middle; font-size: 1.2em;">' + seasonExpandIcon + '</span> ' + 
                                seasonName + seasonStatusHtml + seasonStatsHtml + '</span></td>';
                            seasonRow.setAttribute('data-season-id', seasonId);
                            seasonRow.setAttribute('data-collapsed', isSeasonCollapsed ? 'true' : 'false');
                            
                            tbody.appendChild(seasonRow);
                            
                            // Episode rows (level 3)
                            episodes.forEach(function(video) {
                                var row = createVideoRow(video, true);
                                row.className = 'episode-row';
                                row.style.display = (isSeriesCollapsed || isSeasonCollapsed) ? 'none' : '';
                                row.setAttribute('data-parent-season', seasonId);
                                row.setAttribute('data-parent-series', seriesCollapsedId);
                                tbody.appendChild(row);
                            });
                        });
                    } else {
                        // Render movie
                        var row = createVideoRow(item.data, false);
                        tbody.appendChild(row);
                    }
                });

                // Add click handlers for series headers (level 1)
                document.querySelectorAll('.series-header').forEach(function(header) {
                    header.addEventListener('click', function() {
                        var seriesId = this.getAttribute('data-series-id');
                        var isCollapsed = this.getAttribute('data-collapsed') === 'true';
                        var newCollapsed = !isCollapsed;

                        // Toggle icon
                        var icon = this.querySelector('.material-icons');
                        icon.textContent = newCollapsed ? 'chevron_right' : 'expand_more';

                        // Toggle season headers and episode rows
                        document.querySelectorAll('[data-parent-series="' + seriesId + '"]').forEach(function(row) {
                            if (row.classList.contains('season-header')) {
                                // Show/hide season header
                                row.style.display = newCollapsed ? 'none' : '';
                            } else if (row.classList.contains('episode-row')) {
                                // Episode rows: only show if series is expanded AND season is expanded
                                if (newCollapsed) {
                                    row.style.display = 'none';
                                } else {
                                    var seasonId = row.getAttribute('data-parent-season');
                                    var seasonHeader = document.querySelector('[data-season-id="' + seasonId + '"]');
                                    var seasonCollapsed = seasonHeader && seasonHeader.getAttribute('data-collapsed') === 'true';
                                    row.style.display = seasonCollapsed ? 'none' : '';
                                }
                            }
                        });

                        // Save state in memory only (not localStorage)
                        this.setAttribute('data-collapsed', newCollapsed ? 'true' : 'false');
                        if (newCollapsed) {
                            expandedSeries.delete(seriesId.replace('series-', ''));
                        } else {
                            expandedSeries.add(seriesId.replace('series-', ''));
                        }
                    });
                });

                // Add click handlers for season headers (level 2)
                document.querySelectorAll('.season-header').forEach(function(header) {
                    header.addEventListener('click', function() {
                        var seasonId = this.getAttribute('data-season-id');
                        var isCollapsed = this.getAttribute('data-collapsed') === 'true';
                        var newCollapsed = !isCollapsed;

                        // Toggle icon
                        var icon = this.querySelector('.material-icons');
                        icon.textContent = newCollapsed ? 'chevron_right' : 'expand_more';

                        // Toggle episode rows
                        document.querySelectorAll('[data-parent-season="' + seasonId + '"]').forEach(function(row) {
                            row.style.display = newCollapsed ? 'none' : '';
                        });

                        // Save state in memory only (not localStorage)
                        this.setAttribute('data-collapsed', newCollapsed ? 'true' : 'false');
                        if (newCollapsed) {
                            expandedSeasons.delete(seasonId);
                        } else {
                            expandedSeasons.add(seasonId);
                        }
                    });
                });

                // Add click handlers for extract buttons
                document.querySelectorAll('.btnExtractVideo').forEach(function(btn) {
                    btn.addEventListener('click', function() {
                        var itemId = this.getAttribute('data-id');
                        var itemName = this.getAttribute('data-name');
                        var mode = this.getAttribute('data-mode') || 'extract';
                        if (mode === 'delete') {
                            deleteBinary(itemId, itemName, this);
                        } else {
                            extractVideo(itemId, itemName, this);
                        }
                    });
                });
            }

            function createVideoRow(video, isEpisode) {
                const row = document.createElement('tr');
                const status = video.ambilightStatus;
                var statusIcon = 'pending';
                var statusText = 'Pending';
                var statusColor = '#fbbf24';
                var statusHtml = '';
                
                // Check extraction status properly
                if (status && status.ExtractionStatus === 'extracting') {
                    statusIcon = 'sync';
                    statusText = 'Extracting';
                    statusColor = '#3b82f6';
                    var framesCurrent = status.ExtractionFramesCurrent || 0;
                    var framesTotal = status.ExtractionFramesTotal || 0;
                    var progress = status.ExtractionProgress || 0;
                    var framesText = framesTotal > 0 ? framesCurrent.toLocaleString() + ' / ' + framesTotal.toLocaleString() : 'Starting...';
                    statusHtml = '<span class="material-icons" style="color:' + statusColor + ';vertical-align:middle;font-size:1.2em;animation:spin 2s linear infinite;">' + statusIcon + '</span> ' + statusText + ' (' + framesText + ')';
                } else if (status && status.ExtractionStatus === 'failed') {
                    statusIcon = 'error';
                    statusText = 'Failed';
                    statusColor = '#ef4444';
                    statusHtml = '<span class="material-icons" style="color:' + statusColor + ';vertical-align:middle;font-size:1.2em;">' + statusIcon + '</span> ' + statusText;
                } else if (status && status.HasBinary) {
                    statusIcon = 'check_circle';
                    statusText = 'Extracted';
                    statusColor = '#4ade80';
                    statusHtml = '<span class="material-icons" style="color:' + statusColor + ';vertical-align:middle;font-size:1.2em;">' + statusIcon + '</span> ' + statusText;
                } else {
                    statusHtml = '<span class="material-icons" style="color:' + statusColor + ';vertical-align:middle;font-size:1.2em;">' + statusIcon + '</span> ' + statusText;
                }
                var sizeText = '-';
                if (status && status.HasBinary && status.BinarySize != null) {
                    sizeText = (status.BinarySize / 1024 / 1024).toFixed(2) + ' MB';
                }
                var videoName = video.Name || '';
                var type = video.Type || '';
                var videoIsEpisode = type === 'Episode';
                var seriesName = video.SeriesName || '';
                var seasonNumber = video.ParentIndexNumber != null ? video.ParentIndexNumber : video.SeasonIndexNumber;
                var episodeNumber = video.IndexNumber;
                var typeLabel = videoIsEpisode ? 'Episode' : (type || 'Movie');

                var metaParts = [];
                if (videoIsEpisode && !isEpisode) {
                    // Only show full metadata if not grouped
                    if (seriesName) {
                        metaParts.push(seriesName);
                    }
                    var se = '';
                    if (seasonNumber != null) {
                        var sStr = String(seasonNumber).padStart(2, '0');
                        se += 'S' + sStr;
                    }
                    if (episodeNumber != null) {
                        var eStr = String(episodeNumber).padStart(2, '0');
                        se += (se ? '' : '') + 'E' + eStr;
                    }
                    if (se) {
                        metaParts.push(se);
                    }
                } else if (videoIsEpisode && isEpisode) {
                    // For grouped episodes, show just episode number
                    if (episodeNumber != null) {
                        metaParts.push('Episode ' + episodeNumber);
                    }
                } else if (typeLabel && !videoIsEpisode) {
                    metaParts.push(typeLabel);
                }

                var metaText = metaParts.length ? metaParts.join(' • ') : '';
                var videoId = video.Id || '';
                var isExtracted = !!(status && status.HasBinary);
                var isFailed = !!(status && status.ExtractionStatus === 'failed');
                var isExtracting = !!(status && status.ExtractionStatus === 'extracting');
                var btnHtml = '';

                if (isExtracting) {
                    // Override statusHtml for extracting status with frame info
                    var framesCurrent = status.ExtractionFramesCurrent || 0;
                    var framesTotal = status.ExtractionFramesTotal || 0;
                    var framesText = framesTotal > 0 ? framesCurrent.toLocaleString() + ' / ' + framesTotal.toLocaleString() : 'Starting...';
                    statusHtml = '<span class="material-icons" style="color:#3b82f6;vertical-align:middle;font-size:1.2em;animation:spin 2s linear infinite;">sync</span> Extracting (' + framesText + ')';
                    btnHtml = '<button is="emby-button" class="emby-button raised btnExtractVideo" disabled>Extracting...</button>';
                } else {
                    var btnClass = isExtracted
                        ? 'emby-button raised button-delete btnExtractVideo'
                        : 'emby-button raised button-submit btnExtractVideo';
                    var btnMode = isExtracted ? 'delete' : 'extract';
                    var btnLabel = isExtracted ? 'Delete bin' : 'Extract';
                    btnHtml = '<button data-mode="' + btnMode + '" data-id="' + escapeHtml(videoId) + '" data-name="' + escapeHtml(videoName) + '" is="emby-button" class="' + btnClass + '">' + btnLabel + '</button>';
                }

                var titleCellHtml = escapeHtml(videoName);
                if (metaText) {
                    titleCellHtml += '<div class="fieldDescription">' + escapeHtml(metaText) + '</div>';
                }

                // Indent episode titles if grouped (level 3, so indent more)
                if (isEpisode) {
                    titleCellHtml = '<span style="padding-left: 3em;">' + titleCellHtml + '</span>';
                }

                // Format added date
                var addedDateText = '-';
                if (video.DateCreated) {
                    try {
                        var dateObj = new Date(video.DateCreated);
                        var now = new Date();
                        var diffMs = now - dateObj;
                        var diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

                        if (diffDays === 0) {
                            addedDateText = 'Today';
                        } else if (diffDays === 1) {
                            addedDateText = 'Yesterday';
                        } else if (diffDays < 7) {
                            addedDateText = diffDays + ' days ago';
                        } else if (diffDays < 30) {
                            var weeks = Math.floor(diffDays / 7);
                            addedDateText = weeks + (weeks === 1 ? ' week ago' : ' weeks ago');
                        } else if (diffDays < 365) {
                            var months = Math.floor(diffDays / 30);
                            addedDateText = months + (months === 1 ? ' month ago' : ' months ago');
                        } else {
                            var years = Math.floor(diffDays / 365);
                            addedDateText = years + (years === 1 ? ' year ago' : ' years ago');
                        }

                        // Also show exact date on hover
                        var exactDate = dateObj.toLocaleDateString();
                        addedDateText = '<span title="' + escapeHtml(exactDate) + '">' + addedDateText + '</span>';
                    } catch (e) {
                        addedDateText = '-';
                    }
                }

                row.innerHTML = '<td>' + titleCellHtml + '</td>' +
                    '<td>' + addedDateText + '</td>' +
                    '<td>' + statusHtml + '</td>' +
                    '<td>' + sizeText + '</td>' +
                    '<td>' + btnHtml + '</td>';

                return row;
            }

            async function extractVideo(itemId, itemName, button) {
                try {
                    button.disabled = true;
                    button.textContent = 'Extracting...';

                    var extractUrl = '/Ambilight/Extract/' + itemId;
                    const response = await fetch(extractUrl, {
                        method: 'POST',
                        credentials: 'include'
                    });

                    if (response.ok) {
                        extractingIds[itemId] = true;
                        
                        // Update video status in memory immediately
                        var video = allVideos.find(function(v) { return v.Id === itemId; });
                        if (video) {
                            if (!video.ambilightStatus) video.ambilightStatus = {};
                            video.ambilightStatus.ExtractionStatus = 'extracting';
                            video.ambilightStatus.ExtractionProgress = 0;
                            video.ambilightStatus.ExtractionFramesCurrent = 0;
                            video.ambilightStatus.ExtractionFramesTotal = 0;
                        }
                        
                        renderVideoList();
                        startPolling();
                        showToast('Extraction started for: ' + itemName);
                        setTimeout(function() { pollProgress(); }, 500);
                    } else {
                        throw new Error('Failed to start extraction');
                    }
                } catch (error) {
                    console.error('Error extracting video:', error);
                    showToast('Failed to extract: ' + itemName);
                    button.disabled = false;
                    button.textContent = 'Extract';
                }
            }

            async function deleteBinary(itemId, itemName, button) {
                try {
                    button.disabled = true;
                    button.textContent = 'Deleting...';

                    var deleteUrl = '/Ambilight/Binary/' + itemId;
                    const response = await fetch(deleteUrl, {
                        method: 'DELETE',
                        credentials: 'include'
                    });

                    if (response.ok) {
                        showToast('Deleted ambilight data for: ' + itemName);
                        setTimeout(function () { loadLibrary(); }, 1500);
                    } else {
                        throw new Error('Failed to delete binary');
                    }
                } catch (error) {
                    console.error('Error deleting binary:', error);
                    showToast('Failed to delete ambilight data for: ' + itemName);
                    button.disabled = false;
                    button.textContent = 'Delete bin';
                }
            }

            async function extractAllPending() {
                const pending = allVideos.filter(function(v) { 
                    return !v.ambilightStatus?.HasBinary && v.ambilightStatus?.ExtractionStatus !== 'failed';
                });

                if (pending.length === 0) {
                    showToast('No pending videos to extract');
                    return;
                }

                if (!confirm('Extract ambilight data for ' + pending.length + ' videos? They will be processed sequentially in the background.')) {
                    return;
                }

                try {
                    // Call the server-side batch extraction endpoint
                    const response = await fetch('/Ambilight/ExtractAllPending', {
                        method: 'POST',
                        credentials: 'include'
                    });

                    if (response.ok) {
                        const result = await response.json();
                        showToast(result.Message || 'Extraction queue started');
                        
                        // Start polling to track progress
                        startPolling();
                        
                        // Refresh the list to show updated status
                        setTimeout(function() { loadLibrary(); }, 1000);
                    } else {
                        throw new Error('Failed to start batch extraction');
                    }
                } catch (error) {
                    console.error('Error starting batch extraction:', error);
                    showToast('Failed to start batch extraction: ' + error.message);
                }
            }
            
            function startPolling() {
                if (pollingInterval) return;
                console.log('[Ambilight] Starting progress polling');
                pollingInterval = setInterval(pollProgress, 5000);
            }
            
            function stopPolling() {
                if (pollingInterval) {
                    console.log('[Ambilight] Stopping progress polling');
                    clearInterval(pollingInterval);
                    pollingInterval = null;
                }
            }
            
            async function pollProgress() {
                var extractingVideoIds = Object.keys(extractingIds);
                if (extractingVideoIds.length === 0) {
                    console.log('[Ambilight] No videos extracting, skipping poll');
                    stopPolling();
                    return;
                }
                
                console.log('[Ambilight] Polling progress for', extractingVideoIds.length, 'videos');
                
                try {
                    const response = await fetch('/Ambilight/Status/Batch', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify(extractingVideoIds)
                    });
                    
                    if (!response.ok) {
                        console.error('[Ambilight] Batch poll failed:', response.status);
                        return;
                    }
                    
                    const statuses = await response.json();
                    var completed = [];
                    
                    // Update video statuses
                    for (var videoId in statuses) {
                        var status = statuses[videoId];
                        var video = allVideos.find(function(v) { return v.Id === videoId; });
                        if (video) {
                            video.ambilightStatus = status;
                            
                            console.log('[Ambilight] Progress for', video.Name, ':', 
                                status.ExtractionFramesCurrent, '/', status.ExtractionFramesTotal,
                                'Status:', status.ExtractionStatus);
                            
                            // Check if extraction is complete or failed
                            if (status.ExtractionStatus === 'completed' || status.ExtractionStatus === 'failed') {
                                completed.push(videoId);
                            }
                        }
                    }
                    
                    // Remove completed videos from tracking
                    completed.forEach(function(videoId) {
                        console.log('[Ambilight] Removing completed video from tracking:', videoId);
                        delete extractingIds[videoId];
                    });
                    
                    // Re-render to show updated progress
                    renderVideoList();
                    updateStatistics();
                    
                    // Stop polling if no more videos are extracting
                    if (Object.keys(extractingIds).length === 0) {
                        console.log('[Ambilight] All extractions complete, stopping poll');
                        stopPolling();
                    }
                } catch (e) {
                    console.error('[Ambilight] Batch poll error:', e);
                }
            }

            // Event handlers for manager tab
            if (document.getElementById('btnRefresh')) {
                document.getElementById('btnRefresh').addEventListener('click', loadLibrary);
            }
            if (document.getElementById('btnExtractAll')) {
                document.getElementById('btnExtractAll').addEventListener('click', extractAllPending);
            }
            if (document.getElementById('searchBox')) {
                document.getElementById('searchBox').addEventListener('input', function(e) {
                    currentFilter = e.target.value;
                    renderVideoList();
                });
            }
            if (document.getElementById('statusFilter')) {
                document.getElementById('statusFilter').addEventListener('change', function(e) {
                    currentStatusFilter = e.target.value;
                    renderVideoList();
                });
            }
            if (document.getElementById('typeFilter')) {
                document.getElementById('typeFilter').addEventListener('change', function(e) {
                    currentTypeFilter = e.target.value;
                    renderVideoList();
                });
            }
        </script>
    </div>
</body>
</html>
